/*
 * Copyright 2010-2019 Amazon.com, Inc. or its affiliates. All Rights
 * Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.dynamodbv2;

import static com.amazonaws.services.dynamodbv2.pojos.CustomBooleanClass.CustomBoolean;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTransactionLoadExpression;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTransactionWriteExpression;
import com.amazonaws.services.dynamodbv2.datamodeling.TransactionLoadRequest;
import com.amazonaws.services.dynamodbv2.datamodeling.TransactionWriteRequest;
import com.amazonaws.services.dynamodbv2.datamodeling.TransactionWriteRequest.TransactionWriteOperation;
import com.amazonaws.services.dynamodbv2.model.AttributeDefinition;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.CreateTableRequest;
import com.amazonaws.services.dynamodbv2.model.DeleteTableRequest;
import com.amazonaws.services.dynamodbv2.model.DescribeTableResult;
import com.amazonaws.services.dynamodbv2.model.KeySchemaElement;
import com.amazonaws.services.dynamodbv2.model.KeyType;
import com.amazonaws.services.dynamodbv2.model.ProvisionedThroughput;
import com.amazonaws.services.dynamodbv2.model.ResourceNotFoundException;
import com.amazonaws.services.dynamodbv2.model.ReturnValuesOnConditionCheckFailure;
import com.amazonaws.services.dynamodbv2.model.ScalarAttributeType;
import com.amazonaws.services.dynamodbv2.pojos.AllSupportedAnnotationsClass;
import com.amazonaws.services.dynamodbv2.pojos.AllSupportedDataTypesClass;
import com.amazonaws.services.dynamodbv2.pojos.Currency;
import com.amazonaws.services.dynamodbv2.pojos.CustomBooleanClass;
import com.amazonaws.services.dynamodbv2.pojos.DateRange;
import com.amazonaws.services.dynamodbv2.pojos.HashKeyRangeKeyBothAutoGenerated;
import com.amazonaws.services.dynamodbv2.pojos.HashKeyRangeKeyClass;
import com.amazonaws.services.dynamodbv2.pojos.HashRangeAndOtherAttributeAutoGen;
import com.amazonaws.services.dynamodbv2.pojos.PhoneNumber;
import com.amazonaws.services.dynamodbv2.pojos.RangeKeyClass;
import com.amazonaws.services.dynamodbv2.pojos.SchemaViolatingTestItem;
import com.amazonaws.services.dynamodbv2.pojos.SlimAttributeNamesClass;
import com.amazonaws.services.dynamodbv2.pojos.StringAttributeClass;
import com.amazonaws.services.dynamodbv2.pojos.TestItem;
import com.amazonaws.services.dynamodbv2.util.TableUtils;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

public class TestObjectCreator {

    public static final ProvisionedThroughput DEFAULT_PROVISIONED_THROUGHPUT = new ProvisionedThroughput().withReadCapacityUnits(10L)
                                                                                                          .withWriteCapacityUnits(10L);

    private static final String AWS_JAVA_SDK_UTIL_TABLE_NAME = "aws-java-sdk-util";
    private static final String AWS_JAVA_SDK_DYNAMODB_MAPPER_SAVE_CONFIG_TEST_TABLE_NAME = "aws-java-sdk-dynamodb-mapper-save-config-test";
    private static final String AWS_JAVA_SDK_RANGE_TEST_TABLE_NAME = "aws-java-sdk-range-test";
    private static final String AWS_JAVA_SDK_STRING_RANGE_TABLE_NAME = "aws-java-sdk-string-range";
    private static final String AWS_JAVA_SDK_DOC_ATTRIBUTE_TABLE = "aws-java-sdk-doc-attribute-table";
    private static final String NON_MATCHING_STRING = "NON_MATCHING_STRING";

    // Some random big integer
    private static int start = Integer.parseInt(String.valueOf(System.currentTimeMillis() / 10000));
    private static long startKey = System.currentTimeMillis();

    public static class TransactionLoadTestData {
        private TransactionLoadRequest transactionLoadRequest;
        private List<Object> expectedObjects;

        public TransactionLoadTestData(TransactionLoadRequest transactionLoadRequest, List<Object> expectedObjects) {
            this.transactionLoadRequest = transactionLoadRequest;
            this.expectedObjects = expectedObjects;
        }

        public TransactionLoadRequest getTransactionLoadRequest() {
            return transactionLoadRequest;
        }

        public List<Object> getExpectedObjects() {
            return expectedObjects;
        }
    }

    /**
     * Used to specify number of objects in a {@link TransactionLoadRequest} which have corresponding existing items
     */
    public enum Existence {
        ALL, SOME, NONE
    }

    /**
     * Interface that defines object supplier used when creating objects of same type
     */
    public interface ObjectSupplier {
        Object get();
    }

    /**
     * Used to specify the type of projection expressions to use while creating a {@link TransactionLoadRequest}
     */
    public enum ProjectionExpressionMode {
        NONE,   // No projection expressions for any of the objects

        ONE,    // One object with projection expression (but without expressionAttributeNames), no projection expressions for any of the other objects

        MULTIPLE,   // Multiple objects with projection expressions (but without expressionAttributeNames)

        ONE_ATTRIBUTE_NAMES,    // Multiple objects with projection expressions but only one with expressionAttributeNames

        MULTIPLE_ATTRIBUTE_NAMES,   // Multiple objects with projection expressions and expressionAttributeNames

        ONE_RESERVED_WORD,  // One object with projection expression (but without expressionAttributeNames) containing a reserved word, no projection expressions for any of the other objects

        MIXED_NON_EXISTING_ATTRIBUTES     // One object with expression projecting some existing, some non-existing attributes and one object with expression projecting all non-existing attributes.
                                          // None of these two objects have expressionAttributeNames and no projection expressions for any of the other objects
    }

    public static class TransactionLoadTestDataRequest {
        private int numObjects = 5;
        private Existence existence = Existence.SOME;
        private ProjectionExpressionMode projectionExpressionMode = ProjectionExpressionMode.NONE;
        private boolean useSameObjectType = false;
        private ObjectSupplier objectSupplier;

        public TransactionLoadTestDataRequest withNumObjects(int numObjects) {
            if (numObjects < 0) {
                throw new IllegalArgumentException("numObjects must be greater than zero");
            }
            this.numObjects = numObjects;
            return this;
        }

        public TransactionLoadTestDataRequest withExistence(Existence existence) {
            if (existence == null) {
                throw new IllegalArgumentException("existence must be non-null");
            }
            this.existence = existence;
            return this;
        }

        public TransactionLoadTestDataRequest withProjectionExpressionMode(ProjectionExpressionMode projectionExpressionMode) {
            if (projectionExpressionMode == null) {
                throw new IllegalArgumentException("projectionExpressionMode must be non-null");
            }
            this.projectionExpressionMode = projectionExpressionMode;
            return this;
        }

        public TransactionLoadTestDataRequest withUseSameObjectType(boolean useSameObjectType) {
            this.useSameObjectType = useSameObjectType;
            return this;
        }

        public TransactionLoadTestDataRequest withObjectSupplier(ObjectSupplier objectSupplier) {
            if (objectSupplier == null) {
                throw new IllegalArgumentException("objectSupplier must be non-null");
            }
            if (!useSameObjectType) {
                throw new IllegalArgumentException("useSameObjectType must be set to true before setting objectSupplier");
            }
            this.objectSupplier = objectSupplier;
            return this;
        }
    }

    public static TransactionLoadTestData createMultipleObjectTestDataForTransactionLoad(DynamoDBMapper mapper, TransactionLoadTestDataRequest request) {
        List<Object> expectedObjects = new ArrayList<Object>();
        TransactionLoadRequest transactionLoadRequest = new TransactionLoadRequest();
        for (int i = 0; i < request.numObjects; i++) {
            Object obj = getTestObject(request.useSameObjectType, request.objectSupplier, i);
            TransactionLoadExpressionData expressionData = generateTransactionLoadExpressionData(obj, request.projectionExpressionMode, i);
            transactionLoadRequest.addLoad(obj, expressionData.transactionLoadExpression);

            switch (request.existence) {
                case ALL:
                    mapper.save(obj);
                    expectedObjects.add(expressionData.expectedObject);
                    break;
                case SOME:
                    if (i % 2 == 0) {
                        mapper.save(obj);
                        expectedObjects.add(expressionData.expectedObject);
                    } else {
                        expectedObjects.add(null);
                    }
                    break;
                case NONE:
                    expectedObjects.add(null);
                    break;
                default:
                    throw new IllegalArgumentException("Unhandled existence: " + request.existence);
            }
        }
        return new TransactionLoadTestData(transactionLoadRequest, expectedObjects);
    }

    private static class TransactionLoadExpressionData {
        DynamoDBTransactionLoadExpression transactionLoadExpression;
        Object expectedObject;

        public TransactionLoadExpressionData(DynamoDBTransactionLoadExpression transactionLoadExpression, Object expectedObject) {
            this.transactionLoadExpression = transactionLoadExpression;
            this.expectedObject = expectedObject;
        }
    }

    private enum AttributeProjection {
        SOME, ALL, SOME_NON_EXISTING, ALL_NON_EXISTING
    }

    private static final Map<AttributeProjection, List<String>> stringAttributeClassAttributeProjections;
    static {
        stringAttributeClassAttributeProjections = new HashMap<AttributeProjection, List<String>>();
        stringAttributeClassAttributeProjections.put(AttributeProjection.SOME, Arrays.asList("stringAttribute"));
        stringAttributeClassAttributeProjections.put(AttributeProjection.ALL, Arrays.asList("key", "stringAttribute", "originalName"));
        stringAttributeClassAttributeProjections.put(AttributeProjection.SOME_NON_EXISTING, Arrays.asList("nonExistingAttribute1", "originalName", "nonExistingAttribute2"));
        stringAttributeClassAttributeProjections.put(AttributeProjection.ALL_NON_EXISTING, Arrays.asList("nonExistingAttribute1", "nonExistingAttribute2", "nonExistingAttribute3"));
    }
    private static final Map<AttributeProjection, List<String>> testItemClassAttributeProjections;
    static {
        testItemClassAttributeProjections = new HashMap<AttributeProjection, List<String>>();
        testItemClassAttributeProjections.put(AttributeProjection.SOME, Arrays.asList("rangeKey", "stringAttribute", "stringSetAttribute"));
        testItemClassAttributeProjections.put(AttributeProjection.ALL, Arrays.asList("hashKey", "rangeKey", "stringAttribute", "nonKeyAttribute", "stringSetAttribute"));
        testItemClassAttributeProjections.put(AttributeProjection.SOME_NON_EXISTING, Arrays.asList("nonExistingAttribute1", "nonKeyAttribute", "nonExistingAttribute2"));
        testItemClassAttributeProjections.put(AttributeProjection.ALL_NON_EXISTING, Arrays.asList("nonExistingAttribute1", "nonExistingAttribute2", "nonExistingAttribute3"));
    }
    private static final Map<AttributeProjection, List<String>> rangeKeyClassAttributeProjections;
    static {
        rangeKeyClassAttributeProjections = new HashMap<AttributeProjection, List<String>>();
        rangeKeyClassAttributeProjections.put(AttributeProjection.SOME, Arrays.asList("rangeKey", "stringAttribute", "integerSetAttribute"));
        rangeKeyClassAttributeProjections.put(AttributeProjection.ALL, Arrays.asList("key", "rangeKey", "version", "integerSetAttribute", "stringAttribute", "stringSetAttribute", "bigDecimalAttribute"));
        rangeKeyClassAttributeProjections.put(AttributeProjection.SOME_NON_EXISTING, Arrays.asList("nonExistingAttribute1", "bigDecimalAttribute", "nonExistingAttribute2"));
        rangeKeyClassAttributeProjections.put(AttributeProjection.ALL_NON_EXISTING, Arrays.asList("nonExistingAttribute1", "nonExistingAttribute2", "nonExistingAttribute3"));
    }

    private static TransactionLoadExpressionData generateTransactionLoadExpressionData(Object object, ProjectionExpressionMode expressionMode, int objectNumber) {
        DynamoDBTransactionLoadExpression transactionLoadExpression = null;
        Object expectedObject = object;
        switch (expressionMode) {
            case NONE:
                break;
            case ONE:
                if (objectNumber == 0) {
                    transactionLoadExpression = getTransactionLoadExpression(stringAttributeClassAttributeProjections.get(AttributeProjection.SOME));
                    expectedObject = generateExpectedStringAttributeClassObject((StringAttributeClass) object, AttributeProjection.SOME, false /* excludeKey */);
                }
                break;
            case MULTIPLE:
                if (objectNumber == 0) {
                    return generateTransactionLoadExpressionData(object, AttributeProjection.ALL, true /* excludeKey */);
                } else {
                    return generateTransactionLoadExpressionData(object, AttributeProjection.SOME, false /* excludeKey */);
                }
            case ONE_ATTRIBUTE_NAMES:
                if (objectNumber == 0) {
                    transactionLoadExpression = getTransactionLoadExpressionWithExpressionAttributeNames(stringAttributeClassAttributeProjections.get(AttributeProjection.SOME));
                    expectedObject = generateExpectedStringAttributeClassObject((StringAttributeClass) object, AttributeProjection.SOME, false /* excludeKey */);
                } else {
                    return generateTransactionLoadExpressionData(object, AttributeProjection.SOME, false /* excludeKey */);
                }
                break;
            case MULTIPLE_ATTRIBUTE_NAMES:
                if (objectNumber < 3) {
                    return generateTransactionLoadExpressionData(object, AttributeProjection.SOME, false /* excludeKey */);
                } else {
                    return generateTransactionLoadExpressionDataWithExpressionAttributeNames(object, AttributeProjection.ALL);
                }
            case ONE_RESERVED_WORD:
                if (objectNumber == 0) {
                    transactionLoadExpression = getTransactionLoadExpressionContainingReservedWord();
                    expectedObject = null;
                }
                break;
            case MIXED_NON_EXISTING_ATTRIBUTES:
                if (objectNumber == 0) {
                    transactionLoadExpression = getTransactionLoadExpression(stringAttributeClassAttributeProjections.get(AttributeProjection.ALL_NON_EXISTING));
                    expectedObject = generateExpectedStringAttributeClassObject((StringAttributeClass) object, AttributeProjection.ALL_NON_EXISTING, false /* excludeKey */);
                } else if (objectNumber == 1) {
                    transactionLoadExpression = getTransactionLoadExpression(testItemClassAttributeProjections.get(AttributeProjection.SOME_NON_EXISTING));
                    expectedObject = generateExpectedTestItemObject((TestItem) object, AttributeProjection.SOME_NON_EXISTING);
                }
                break;
            default:
                throw new IllegalArgumentException("Unsupported projectionExpressionMode: " + expressionMode);
        }
        return new TransactionLoadExpressionData(transactionLoadExpression,  expectedObject);
    }

    /**
     * Since this method doesn't use expressionAttributeNames for generating load expression data, if an attribute name is "key" then we may want to remove it
     * from projected attributes as it is a reserved keyword. If excludeKey is true then attribute with name "key" is removed from projected attributes and not
     * included in expected object.
     */
    private static TransactionLoadExpressionData generateTransactionLoadExpressionData(Object object, AttributeProjection attributeProjection, boolean excludeKey) {
        List<String> attributeNamesToProject;
        Object expectedObject;
        if (StringAttributeClass.class.equals(object.getClass())) {
            attributeNamesToProject = stringAttributeClassAttributeProjections.get(attributeProjection);
            expectedObject = generateExpectedStringAttributeClassObject((StringAttributeClass) object, attributeProjection, excludeKey /* excludeKey */);
        } else if (TestItem.class.equals(object.getClass())) {
            attributeNamesToProject = testItemClassAttributeProjections.get(attributeProjection);
            expectedObject = generateExpectedTestItemObject((TestItem) object, attributeProjection);
        } else if (RangeKeyClass.class.equals(object.getClass())) {
            attributeNamesToProject = rangeKeyClassAttributeProjections.get(attributeProjection);
            expectedObject = generateExpectedRangeKeyClassObject((RangeKeyClass) object, attributeProjection, excludeKey);
        } else {
            throw new IllegalArgumentException("Unsupported object type: " + object.getClass());
        }
        if (excludeKey) {
            attributeNamesToProject = excludeKeyFromAttributeNames(attributeNamesToProject);
        }
        DynamoDBTransactionLoadExpression transactionLoadExpression = getTransactionLoadExpression(attributeNamesToProject);
        return new TransactionLoadExpressionData(transactionLoadExpression, expectedObject);
    }

    private static List<String> excludeKeyFromAttributeNames(List<String> attributeNames) {
        List<String> result = new ArrayList<String>();
        for (String attributeName: attributeNames) {
            if (!"key".equalsIgnoreCase(attributeName)) {
                result.add(attributeName);
            }
        }
        return result;
    }

    private static TransactionLoadExpressionData generateTransactionLoadExpressionDataWithExpressionAttributeNames(Object object, AttributeProjection attributeProjection) {
        Object expectedObject;
        List<String> attributeNamesToProject;
        if (StringAttributeClass.class.equals(object.getClass())) {
            attributeNamesToProject = stringAttributeClassAttributeProjections.get(attributeProjection);
            expectedObject = generateExpectedStringAttributeClassObject((StringAttributeClass) object, attributeProjection, false /* excludeKey */);
        } else if (TestItem.class.equals(object.getClass())) {
            attributeNamesToProject = testItemClassAttributeProjections.get(attributeProjection);
            expectedObject = generateExpectedTestItemObject((TestItem) object, attributeProjection);
        } else if (RangeKeyClass.class.equals(object.getClass())) {
            attributeNamesToProject = rangeKeyClassAttributeProjections.get(attributeProjection);
            expectedObject = generateExpectedRangeKeyClassObject((RangeKeyClass) object, attributeProjection, false /* excludeKey */);
        } else {
            throw new IllegalArgumentException("Unsupported object type: " + object.getClass());
        }
        DynamoDBTransactionLoadExpression transactionLoadExpression = getTransactionLoadExpressionWithExpressionAttributeNames(attributeNamesToProject);
        return new TransactionLoadExpressionData(transactionLoadExpression, expectedObject);
    }

    private static StringAttributeClass generateExpectedStringAttributeClassObject(StringAttributeClass sourceObject, AttributeProjection attributeProjection, boolean excludeKey) {
        StringAttributeClass expectedObject = new StringAttributeClass();
        switch (attributeProjection) {
            case SOME:
                expectedObject.setStringAttribute(sourceObject.getStringAttribute());
                return expectedObject;
            case ALL:
                if (!excludeKey) {
                    expectedObject.setKey(sourceObject.getKey());
                }
                expectedObject.setStringAttribute(sourceObject.getStringAttribute());
                expectedObject.setRenamedAttribute(sourceObject.getRenamedAttribute());
                return expectedObject;
            case SOME_NON_EXISTING:
                expectedObject.setRenamedAttribute(sourceObject.getRenamedAttribute());
                return expectedObject;
            case ALL_NON_EXISTING:
                return null;
            default:
                throw new IllegalArgumentException("Unsupported attributeProjection: " + attributeProjection);
        }
    }

    private static TestItem generateExpectedTestItemObject(TestItem sourceObject, AttributeProjection attributeProjection) {
        TestItem expectedObject = new TestItem();
        switch (attributeProjection) {
            case SOME:
                expectedObject.setRangeKey(sourceObject.getRangeKey());
                expectedObject.setStringAttribute(sourceObject.getStringAttribute());
                expectedObject.setStringSetAttribute(sourceObject.getStringSetAttribute());
                return expectedObject;
            case ALL:
                expectedObject.setHashKey(sourceObject.getHashKey());
                expectedObject.setRangeKey(sourceObject.getRangeKey());
                expectedObject.setStringAttribute(sourceObject.getStringAttribute());
                expectedObject.setNonKeyAttribute(sourceObject.getNonKeyAttribute());
                expectedObject.setStringSetAttribute(sourceObject.getStringSetAttribute());
                return expectedObject;
            case SOME_NON_EXISTING:
                expectedObject.setNonKeyAttribute(sourceObject.getNonKeyAttribute());
                return expectedObject;
            case ALL_NON_EXISTING:
                return null;
            default:
                throw new IllegalArgumentException("Unsupported attributeProjection: " + attributeProjection);
        }
    }

    private static RangeKeyClass generateExpectedRangeKeyClassObject(RangeKeyClass sourceObject, AttributeProjection attributeProjection, boolean excludeKey) {
        RangeKeyClass expectedObject = new RangeKeyClass();
        switch (attributeProjection) {
            case SOME:
                expectedObject.setRangeKey(sourceObject.getRangeKey());
                expectedObject.setStringAttribute(sourceObject.getStringAttribute());
                expectedObject.setIntegerAttribute(sourceObject.getIntegerAttribute());
                return expectedObject;
            case ALL:
                if (!excludeKey) {
                    expectedObject.setKey(sourceObject.getKey());
                }
                expectedObject.setRangeKey(sourceObject.getRangeKey());
                expectedObject.setVersion(sourceObject.getVersion());
                expectedObject.setIntegerAttribute(sourceObject.getIntegerAttribute());
                expectedObject.setStringAttribute(sourceObject.getStringAttribute());
                expectedObject.setStringSetAttribute(sourceObject.getStringSetAttribute());
                expectedObject.setBigDecimalAttribute(sourceObject.getBigDecimalAttribute());
                return expectedObject;
            case SOME_NON_EXISTING:
                expectedObject.setBigDecimalAttribute(sourceObject.getBigDecimalAttribute());
                return expectedObject;
            case ALL_NON_EXISTING:
                return null;
            default:
                throw new IllegalArgumentException("Unsupported attributeProjection: " + attributeProjection);
        }
    }

    private static DynamoDBTransactionLoadExpression getTransactionLoadExpression(List<String> attributeNames) {
        if (attributeNames.isEmpty()) {
            return null;
        }
        StringBuilder projectionExpressionBuilder = new StringBuilder(attributeNames.get(0));
        for (int i = 1; i < attributeNames.size(); i++) {
            projectionExpressionBuilder.append(", " + attributeNames.get(i));
        }
        return new DynamoDBTransactionLoadExpression().withProjectionExpression(projectionExpressionBuilder.toString());
    }

    private static DynamoDBTransactionLoadExpression getTransactionLoadExpressionWithExpressionAttributeNames(List<String> attributeNames) {
        if (attributeNames.isEmpty()) {
            return null;
        }
        String firstAttributeName = attributeNames.get(0);
        String tokenBase = "u7q3j";
        String currentTokenString = "#" + tokenBase + "0";
        StringBuilder projectionExpressionBuilder = new StringBuilder(currentTokenString);
        Map<String, String> expressionAttributeNames = new HashMap<String, String>();
        expressionAttributeNames.put(currentTokenString, firstAttributeName);
        for (int i = 1; i < attributeNames.size(); i++) {
            currentTokenString = "#" + tokenBase + i;
            projectionExpressionBuilder.append(", " + currentTokenString);
            expressionAttributeNames.put(currentTokenString, attributeNames.get(i));
        }
        return new DynamoDBTransactionLoadExpression().withProjectionExpression(projectionExpressionBuilder.toString())
                                                      .withExpressionAttributeNames(expressionAttributeNames);
    }

    private static DynamoDBTransactionLoadExpression getTransactionLoadExpressionContainingReservedWord() {
        return new DynamoDBTransactionLoadExpression().withProjectionExpression("stringAttribute, SET");
    }

    public static Object getTestObject(boolean useSameObjectType, ObjectSupplier objectSupplier, int tableNumber) {
        if (useSameObjectType) {
            if (objectSupplier != null) {
                return objectSupplier.get();
            }
            return getStringAttributeClass();
        }
        if (tableNumber % 3 == 0) {
            return getStringAttributeClass();
        }
        if (tableNumber % 3 == 1) {
            return getTestItemObject();
        }
        return getUniqueRangeKeyObject();
    }

    public static Object getTestObject(boolean isMultiTable, int tableNumber) {
        if (!isMultiTable) {
            return getStringAttributeClass();
        }
        if (tableNumber % 3 == 0) {
            return getStringAttributeClass();
        }
        if (tableNumber % 3 == 1) {
            return getTestItemObject();
        }
        return getHashKeyRangeKeyObject();
    }

    public static List<Object> getMultiTableObjects(int numItems) {
        List<Object> objs = new ArrayList<Object>();
        for (int i = 0; i < numItems / 2; i++) {
            StringAttributeClass obj = getStringAttributeClass();
            objs.add(obj);
        }
        for (int i = 0; i < numItems / 2; i++) {
            TestItem obj = getTestItemObject();
            objs.add(obj);
        }
        return objs;
    }

    public static StringAttributeClass getStringAttributeClass() {
        StringAttributeClass obj = new StringAttributeClass();
        obj.setKey(String.valueOf(startKey++));
        obj.setRenamedAttribute(String.valueOf(startKey++));
        obj.setStringAttribute(String.valueOf(startKey++));
        return obj;
    }

    public static TestItem getTestItemObject() {
        TestItem obj = new TestItem();
        obj.setHashKey(UUID.randomUUID().toString());
        obj.setRangeKey(System.currentTimeMillis());
        obj.setStringAttribute(String.valueOf(startKey++));
        obj.setStringSetAttribute(generateRandomStringSet(3));
        obj.setNonKeyAttribute(String.valueOf(startKey++));
        return obj;
    }

    public static SchemaViolatingTestItem getSchemaViolatingTestItemObject() {
        SchemaViolatingTestItem obj = new SchemaViolatingTestItem();
        obj.setHashKey(UUID.randomUUID().toString());
        obj.setRangeKey(System.currentTimeMillis());
        return obj;
    }

    public static RangeKeyClass getUniqueRangeKeyObject() {
        RangeKeyClass obj = new RangeKeyClass();
        obj.setKey(startKey++);
        obj.setIntegerAttribute(toSet(start++, start++, start++, start++));
        obj.setBigDecimalAttribute(new BigDecimal(startKey++));
        obj.setRangeKey(start++);
        obj.setStringAttribute("" + startKey++);
        obj.setStringSetAttribute(generateRandomStringSet(3));
        return obj;
    }

    public static HashKeyRangeKeyBothAutoGenerated getStringHashAndRangeKeyObjectWithKeys() {
        HashKeyRangeKeyBothAutoGenerated obj = new HashKeyRangeKeyBothAutoGenerated();
        String uuid = UUID.randomUUID().toString();
        obj.setKey("hash_" + uuid);
        obj.setRangeKey("range_" + uuid);
        obj.setOtherAttribute("otherAttribute_" + uuid);
        return obj;
    }

    public static CustomBooleanClass getCustomBooleanClassObject() {
        CustomBooleanClass obj = new CustomBooleanClass();
        String uuid = UUID.randomUUID().toString();
        obj.setKey(uuid);
        obj.setCustomBooleanAttribute(new CustomBoolean(true));
        return obj;
    }

    public static HashKeyRangeKeyClass getHashKeyRangeKeyObject() {
        HashKeyRangeKeyClass obj = new HashKeyRangeKeyClass();
        obj.setHashKey(startKey++);
        obj.setRangeKey(start++);
        obj.setStringAttribute("" + startKey++);
        return obj;
    }

    public static AllSupportedDataTypesClass getAllSupportedDataTypesObject() {
        AllSupportedDataTypesClass obj = new AllSupportedDataTypesClass();
        String uuid = UUID.randomUUID().toString();
        obj.setKey("hash_" + uuid);
        obj.setRangeKey("range_" + uuid);
        obj.setBigDecimalAttribute(new BigDecimal(startKey++));
        obj.setBigDecimalSetAttribute(toSet(new BigDecimal(startKey++), new BigDecimal(startKey++), new BigDecimal(startKey++)));
        obj.setBigIntegerAttribute(BigInteger.valueOf(startKey++));
        obj.setBigIntegerSetAttribute(toSet(BigInteger.valueOf(startKey++), BigInteger.valueOf(startKey++), BigInteger.valueOf(startKey++)));
        obj.setBooleanAttribute(start++ % 2 == 0);
        obj.setBooleanSetAttribute(toSet(true, false));
        obj.setByteAttribute((byte) start++);
        obj.setByteSetAttribute(toSet((byte) start++, (byte) start++, (byte) start++));
        obj.setCalendarAttribute(getCalendarObject());
        obj.setCalendarSetAttribute(toSet(getCalendarObject(), getCalendarObject(), getCalendarObject()));
        obj.setDateAttribute(new Date(startKey++));
        obj.setDateSetAttribute(toSet(new Date(startKey++), new Date(startKey++), new Date(startKey++)));
        obj.setDoubleAttribute((double) startKey++);
        obj.setDoubleSetAttribute(toSet((double) startKey++, (double) startKey++, (double) startKey++));
        obj.setFloatAttribute((float) start++);
        obj.setFloatSetAttribute(toSet((float) start++, (float) start++, (float) start++));
        obj.setIntegerAttribute(start++);
        obj.setIntegerSetAttribute(toSet(start++, start++, start++));
        obj.setLongAttribute(startKey++);
        obj.setLongSetAttribute(toSet(startKey++, startKey++, startKey++));
        obj.setStringAttribute("stringAttribute_" + uuid);
        obj.setStringSetAttribute(toSet("stringSetAttribute_1_" + uuid, "stringSetAttribute_2_" + uuid, "stringSetAttribute_3_" + uuid));
        return obj;
    }

    public static AllSupportedAnnotationsClass getAllSupportedAnnotationsObject() {
        AllSupportedAnnotationsClass obj = new AllSupportedAnnotationsClass();
        String uuid = UUID.randomUUID().toString();
        obj.setId("hash_" + uuid);
        obj.setRangeKey("range_" + uuid);
        obj.setIntegerAttribute(start++);
        obj.setBooleanAttribute(true);
        obj.setPhoneNumber(new PhoneNumber("xyz", "867", "5309"));
        obj.setIgnoredAttribute("IgnoredString_" + uuid);
        obj.setGsiHashKey("gsi_hash_" + uuid);
        obj.setGsiRangeKey("gsi_range_" + uuid);
        obj.setNamedAttribute("namedAttribute_" + uuid);
        obj.setCurrencyAttribute(new Currency((double) startKey++, "USD"));
        obj.setEpochDate(new Date(startKey++));
        obj.setDateRange(new DateRange(new Date(startKey++), -60000L, 60000L));
        return obj;
    }

    private static Calendar getCalendarObject() {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date(startKey++));
        return calendar;
    }

    public static HashRangeAndOtherAttributeAutoGen getHashRangeAutoGenOtherAttributeObject() {
        HashRangeAndOtherAttributeAutoGen obj = new HashRangeAndOtherAttributeAutoGen();
        String uuid = UUID.randomUUID().toString();
        obj.setKey("hash_" + uuid);
        obj.setRangeKey("range_" + uuid);
        obj.setDate(new Date());
        return obj;
    }

    public static SlimAttributeNamesClass getSlimAttributeNamesClass() {
        SlimAttributeNamesClass obj = new SlimAttributeNamesClass();
        String uuid = UUID.randomUUID().toString();
        obj.setHashKey("hash_" + uuid);
        obj.setRangeKey(startKey++);
        obj.setZ("Z_" + uuid);
        obj.setA("A_" + uuid);
        obj.setL("L_" + uuid);
        obj.setC("C_" + uuid);
        obj.setG("G_" + uuid);
        obj.setM("M_" + uuid);
        return obj;
    }

    private static Set<String> generateRandomStringSet(int size) {
        Set<String> result = new HashSet<String>();
        for (int i = 0; i < size; i++) {
            result.add(UUID.randomUUID().toString());
        }
        return result;
    }

    private static <T extends Object> Set<T> toSet(T... array) {
        Set<T> set = new HashSet<T>();
        for (T t : array) {
            set.add(t);
        }
        return set;
    }

    public static void createStringHashKeyTable(AmazonDynamoDB dynamoDB) throws InterruptedException {
        createStringHashKeyTable(dynamoDB, AWS_JAVA_SDK_UTIL_TABLE_NAME);
    }

    public static void createStringHashKeyTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "key" /* hashKeyName */,
                        ScalarAttributeType.S,
                        null /* rangeKeyName */,
                        null /* rangeKeyAttributeType */);
    }

    public static void createSdkMapperSaveConfigTable(AmazonDynamoDB dynamoDB) throws InterruptedException {
        createSdkMapperSaveConfigTable(dynamoDB, AWS_JAVA_SDK_DYNAMODB_MAPPER_SAVE_CONFIG_TEST_TABLE_NAME);
    }

    public static void createSdkMapperSaveConfigTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "hashKey",
                        ScalarAttributeType.S,
                        "rangeKey",
                        ScalarAttributeType.N);
    }

    public static void createSdkRangeTestTable(AmazonDynamoDB dynamoDB) throws InterruptedException {
        createSdkRangeTestTable(dynamoDB, AWS_JAVA_SDK_RANGE_TEST_TABLE_NAME);
    }

    public static void createSdkRangeTestTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "key",
                        ScalarAttributeType.N,
                        "rangeKey",
                        ScalarAttributeType.N);
    }

    public static void createSdkStringRangeTable(AmazonDynamoDB dynamoDB) throws InterruptedException {
        createSdkStringRangeTable(dynamoDB, AWS_JAVA_SDK_STRING_RANGE_TABLE_NAME);
    }

    public static void createSdkStringRangeTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "key",
                        ScalarAttributeType.S,
                        "rangeKey",
                        ScalarAttributeType.S);
    }

    public static void createHashKeyRangeKeyTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "hashKey",
                        ScalarAttributeType.N,
                        "rangeKey",
                        ScalarAttributeType.N);
    }

    public static void createSdkDocAttributeTable(AmazonDynamoDB dynamoDB) throws InterruptedException {
        createSdkDocAttributeTable(dynamoDB, AWS_JAVA_SDK_DOC_ATTRIBUTE_TABLE);
    }

    public static void createSdkDocAttributeTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "id" /* hashKeyName */,
                        ScalarAttributeType.S,
                        null /* rangeKeyName */,
                        null /* rangeKeyAttributeType */);
    }

    public static void createAllSupportedAnnotationsTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        createTestTable(dynamoDB, DEFAULT_PROVISIONED_THROUGHPUT,
                        tableName,
                        "id" /* hashKeyName */,
                        ScalarAttributeType.S,
                        "rangeKey" /* rangeKeyName */,
                        ScalarAttributeType.S);
    }

    /**
     * Helper method to create a table in Amazon DynamoDB.
     * Waits till the table becomes active.
     *
     * rangeKeyName and rangeKeyAttributeType are optional.
     *
     */
    public static void createTestTable(AmazonDynamoDB dynamoDB,
                                       ProvisionedThroughput provisionedThroughput,
                                       String tableName,
                                       String hashKeyName,
                                       ScalarAttributeType hashKeyAttributeType,
                                       String rangeKeyName,
                                       ScalarAttributeType rangeKeyAttributeType) throws InterruptedException {
        CreateTableRequest createTableRequest = null;
        createTableRequest = new CreateTableRequest()
                                     .withTableName(tableName)
                                     .withKeySchema(
                                             new KeySchemaElement().withAttributeName(
                                                     hashKeyName).withKeyType(
                                                     KeyType.HASH))
                                     .withAttributeDefinitions(
                                             new AttributeDefinition().withAttributeName(
                                                     hashKeyName).withAttributeType(
                                                     hashKeyAttributeType));

        if (rangeKeyName != null) {
            createTableRequest
                    .withKeySchema(
                            new KeySchemaElement().withAttributeName(
                                    rangeKeyName).withKeyType(
                                    KeyType.RANGE))

                    .withAttributeDefinitions(
                            new AttributeDefinition().withAttributeName(
                                    rangeKeyName).withAttributeType(
                                    rangeKeyAttributeType));
        }
        createTableRequest.setProvisionedThroughput(provisionedThroughput);

        if (TableUtils.createTableIfNotExists(dynamoDB, createTableRequest)) {
            TableUtils.waitUntilActive(dynamoDB, tableName);
        }
    }

    /**
     * Helper method to delete a table in Amazon DynamoDB.
     * Waits till the table becomes deleted or transitions to DELETING state.
     */
    public static void deleteTestTable(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        DeleteTableRequest deleteTableRequest = new DeleteTableRequest().withTableName(tableName);

        if (TableUtils.deleteTableIfExists(dynamoDB, deleteTableRequest)) {
            waitUntilTableDeletedOrInDeleting(dynamoDB, tableName);
        }
    }

    private static void waitUntilTableDeletedOrInDeleting(AmazonDynamoDB dynamoDB, String tableName) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        // Wait up to one minute for a table to be deleted or transition to DELETING state.
        long endTime = startTime + 60 * 1000;
        while (System.currentTimeMillis() < endTime) {
            try {
                DescribeTableResult describeTableResult = dynamoDB.describeTable(tableName);
                if ("DELETING".equals(describeTableResult.getTable().getTableStatus())) {
                    // Table will eventually get deleted, stopping to wait here reduces test run time by more than half
                    return;
                }
                Thread.sleep(1000);
            } catch (ResourceNotFoundException e) {
                return;
            }
        }
    }

    // Denotes the number of a given type of operations in a transactionWriteRequest
    // having condition expressions
    public enum ConditionExpressionMode {
        NONE, // None of the items have condition expressions.
        ONE, // Only one item has condition expression with neither attributeName map nor attributeValue map, a simple condition expression
        ONE_ATTRIBUTE_NAMES_ONLY, // One item has condition expression with attributeName map but no attributeValue map, other item has simple condition expression
        ONE_ATTRIBUTE_VALUES_ONLY, // One item has condition expression with no attributeName map but with attributeValue map, other item has simple condition expression
        ONE_ATTRIBUTE_NAMES_VALUES, // One item has condition expression with attributeName map and with attributeValue map, other item has simple condition expression
        ONE_INVALID_RETURN_VALUES_SET, // One item has condition expression that has failing condition expression, other item has simple condition expression
        ONE_RESERVED_WORD, // only one item has condition expression with restricted word
        MULTIPLE, // Multiple items have condition expression with neither attributeName map nor attributeValue map
        MULTIPLE_ATTRIBUTE_NAMES_ONLY, // Multiple items have condition expression with attributeName map but no attributeValue map
        MULTIPLE_ATTRIBUTE_VALUES_ONLY, // Multiple items have condition expression with no attributeName map but with attributeValue map
        MULTIPLE_ATTRIBUTE_NAMES_VALUES, // Multiple items have condition expression with attributeName map and with attributeValue map
        MULTIPLE_INVALID_RETURN_VALUES_SET // Multiple items have condition expression that has failing condition expression
    }

    public static class TransactionWriteTestRequest {
        private ConditionExpressionMode putConditionExpressionMode = ConditionExpressionMode.NONE;
        private ConditionExpressionMode updateConditionExpressionMode = ConditionExpressionMode.NONE;
        private ConditionExpressionMode deleteConditionExpressionMode = ConditionExpressionMode.NONE;
        private ConditionExpressionMode conditionCheckConditionExpressionMode = ConditionExpressionMode.MULTIPLE;
        private boolean isMultiTable = true; // Majority of tests depend on objects from multiple tables

        public TransactionWriteTestRequest withPutConditionExpressionMode(ConditionExpressionMode putConditionExpressionMode) {
            this.putConditionExpressionMode = putConditionExpressionMode;
            return this;
        }

        public TransactionWriteTestRequest withUpdateConditionExpressionMode(ConditionExpressionMode updateConditionExpressionMode) {
            this.updateConditionExpressionMode = updateConditionExpressionMode;
            return this;
        }

        public TransactionWriteTestRequest withDeleteConditionExpressionMode(ConditionExpressionMode deleteConditionExpressionMode) {
            this.deleteConditionExpressionMode = deleteConditionExpressionMode;
            return this;
        }

        public TransactionWriteTestRequest withConditionCheckConditionExpressionMode(ConditionExpressionMode conditionCheckConditionExpressionMode) {
            this.conditionCheckConditionExpressionMode = conditionCheckConditionExpressionMode;
            return this;
        }

        public TransactionWriteTestRequest withIsMultiTable(boolean isMultiTable) {
            this.isMultiTable = isMultiTable;
            return this;
        }

    }

    public static class TransactionWriteTestData {
        private TransactionWriteRequest transactionWriteRequest;
        private List<Object> expectedObjectKeys;
        private List<Object> expectedObjects;
        private List<Object> oldExistingObjects;

        public TransactionWriteTestData(TransactionWriteRequest transactionWriteRequest,
                                        List<Object> expectedObjectKeys,
                                        List<Object> expectedObjects,
                                        List<Object> oldExistingObjects) {
            this.transactionWriteRequest = transactionWriteRequest;
            this.expectedObjectKeys = expectedObjectKeys;
            this.expectedObjects = expectedObjects;
            this.oldExistingObjects = oldExistingObjects;
        }

        public TransactionWriteRequest getTransactionWriteRequest() {
            return transactionWriteRequest;
        }

        public List<Object> getExpectedObjectKeys() {
            return expectedObjectKeys;
        }

        public List<Object> getExpectedObjects() {
            return expectedObjects;
        }

        public List<Object> getOldExistingObjects() {
            return oldExistingObjects;
        }

    }

    public static TransactionWriteTestData createMultipleObjectTestDataForTransactionWrite(DynamoDBMapper dynamoDBMapper,
                                                                                           TransactionWriteTestRequest transactionWriteTestRequest) {
        TransactionWriteRequest transactionWriteRequest = new TransactionWriteRequest();
        List<Object> responseObjectKeys = new ArrayList<Object>();
        List<Object> expectedResponseObjects = new ArrayList<Object>();
        List<Object> oldExistingObjects = new ArrayList<Object>();
        WriteExpressionAndReturnValue writeExpressionAndReturnValue;

        // Create and add Put operations
        for (int i = 0; i < 3; i++) {
            Object obj = getTestObject(transactionWriteTestRequest.isMultiTable, i);
            if (!transactionWriteTestRequest.putConditionExpressionMode.equals(ConditionExpressionMode.NONE)) {
                dynamoDBMapper.save(obj);
                oldExistingObjects.add(obj);
            }
            writeExpressionAndReturnValue = generateWriteExpressionAndReturnValueFlag(obj, transactionWriteTestRequest.putConditionExpressionMode, i);
            transactionWriteRequest.addPut(obj, writeExpressionAndReturnValue.dynamoDBTransactionWriteExpression, writeExpressionAndReturnValue.returnValuesOnConditionCheckFailure);
            responseObjectKeys.add(obj);
            expectedResponseObjects.add(obj);
        }

        // Create and add update operations
        for (int i = 0; i < 3; i++) {
            Object obj = getTestObject(transactionWriteTestRequest.isMultiTable, i);
            writeExpressionAndReturnValue = generateWriteExpressionAndReturnValueFlag(obj, transactionWriteTestRequest.updateConditionExpressionMode, i);
            dynamoDBMapper.save(obj);
            // Make a copy since update item updates the object.
            Object newObj = copyTransactWriteItemTestObject(obj);
            oldExistingObjects.add(newObj);
            updateUpdateObject(obj);
            transactionWriteRequest.addUpdate(obj, writeExpressionAndReturnValue.dynamoDBTransactionWriteExpression, writeExpressionAndReturnValue.returnValuesOnConditionCheckFailure);
            responseObjectKeys.add(obj);
            expectedResponseObjects.add(obj);
        }

        // Create and add conditionCheck operations
        for (int i = 0; i < 2; i++) {
            Object obj = getTestObject(transactionWriteTestRequest.isMultiTable, i);
            writeExpressionAndReturnValue = generateWriteExpressionAndReturnValueFlag(obj, transactionWriteTestRequest.conditionCheckConditionExpressionMode, i);
            dynamoDBMapper.save(obj);
            oldExistingObjects.add(obj);
            transactionWriteRequest.addConditionCheck(obj, writeExpressionAndReturnValue.dynamoDBTransactionWriteExpression, writeExpressionAndReturnValue.returnValuesOnConditionCheckFailure);
        }

        // Create and add delete operations
        for (int i = 0; i < 2; i++) {
            Object obj = getTestObject(transactionWriteTestRequest.isMultiTable, i);
            writeExpressionAndReturnValue = generateWriteExpressionAndReturnValueFlag(obj, transactionWriteTestRequest.deleteConditionExpressionMode, i);
            dynamoDBMapper.save(obj);
            transactionWriteRequest.addDelete(obj, writeExpressionAndReturnValue.dynamoDBTransactionWriteExpression, writeExpressionAndReturnValue.returnValuesOnConditionCheckFailure);
            responseObjectKeys.add(obj);
            oldExistingObjects.add(obj);
            expectedResponseObjects.add(null);
        }

        return new TransactionWriteTestData(transactionWriteRequest, responseObjectKeys, expectedResponseObjects, oldExistingObjects);
    }

    private static class WriteExpressionAndReturnValue {
        DynamoDBTransactionWriteExpression dynamoDBTransactionWriteExpression;
        ReturnValuesOnConditionCheckFailure returnValuesOnConditionCheckFailure;

        public WriteExpressionAndReturnValue(DynamoDBTransactionWriteExpression dynamoDBTransactionWriteExpression,
                                             ReturnValuesOnConditionCheckFailure returnValuesOnConditionCheckFailure) {
            this.dynamoDBTransactionWriteExpression = dynamoDBTransactionWriteExpression;
            this.returnValuesOnConditionCheckFailure = returnValuesOnConditionCheckFailure;
        }
    }

    private static void updateUpdateObject(Object obj) {
        Class clazz = obj.getClass();
        String updatedStringAttribute = "updatedStringAttribute";
        if (clazz.equals(StringAttributeClass.class)) {
            ((StringAttributeClass) obj).setStringAttribute(updatedStringAttribute);
        } else if (clazz.equals(TestItem.class)) {
            ((TestItem) obj).setStringAttribute(updatedStringAttribute);
        } else if (clazz.equals(HashKeyRangeKeyClass.class)) {
            ((HashKeyRangeKeyClass) obj).setStringAttribute(updatedStringAttribute);
        } else {
            throw new IllegalArgumentException("Received a class that is not supported for request generation, class: " + clazz);
        }
    }

    private static WriteExpressionAndReturnValue generateWriteExpressionAndReturnValueFlag(Object obj,
                                                                                           ConditionExpressionMode conditionExpressionMode,
                                                                                           int tableNumber) {
        Class clazz = obj.getClass();
        String stringAttribute;
        DynamoDBTransactionWriteExpression dynamoDBTransactionWriteExpression = null;
        ReturnValuesOnConditionCheckFailure returnValuesOnConditionCheckFailure = null;
        if (clazz.equals(StringAttributeClass.class)) {
            stringAttribute = ((StringAttributeClass) obj).getStringAttribute();
        } else if (clazz.equals(TestItem.class)) {
            stringAttribute = ((TestItem) obj).getStringAttribute();
        } else if (clazz.equals(HashKeyRangeKeyClass.class)) {
            stringAttribute = ((HashKeyRangeKeyClass) obj).getStringAttribute();
        } else {
            throw new IllegalArgumentException("Received a class that is not supported for request generation, class: " + clazz);
        }
        switch (conditionExpressionMode) {
            case NONE:
                break;
            case ONE:
                if (tableNumber % 3 == 0) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsTransactWriteExpression();
                }
                break;
            case MULTIPLE:
                if (tableNumber % 3 == 0 || tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsTransactWriteExpression();
                }
                break;
            case ONE_ATTRIBUTE_NAMES_VALUES:
                if (tableNumber % 3 == 0) {
                    dynamoDBTransactionWriteExpression = generateStringMatcherTransactWriteExpression(stringAttribute, NON_MATCHING_STRING);
                } else if (tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsTransactWriteExpression();
                }
                break;
            case MULTIPLE_ATTRIBUTE_NAMES_VALUES:
                if (tableNumber % 3 == 0 || tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringMatcherTransactWriteExpression(stringAttribute, NON_MATCHING_STRING);
                }
                break;
            case ONE_ATTRIBUTE_NAMES_ONLY:
                if (tableNumber % 3 == 0) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsWithExpressionAttributeNameTransactWriteExpression();
                } else if (tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsTransactWriteExpression();
                }
                break;
            case ONE_ATTRIBUTE_VALUES_ONLY:
                if (tableNumber % 3 == 0) {
                    dynamoDBTransactionWriteExpression = generateStringContainsWithExpressionAttributeValuesTransactWriteExpression(stringAttribute.substring(2));
                } else if (tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsTransactWriteExpression();
                }
                break;
            case MULTIPLE_ATTRIBUTE_NAMES_ONLY:
                if (tableNumber % 3 == 0 || tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsWithExpressionAttributeNameTransactWriteExpression();
                }
                break;
            case MULTIPLE_ATTRIBUTE_VALUES_ONLY:
                if (tableNumber % 3 == 0 || tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringContainsWithExpressionAttributeValuesTransactWriteExpression(stringAttribute.substring(2));
                }
                break;
            case ONE_INVALID_RETURN_VALUES_SET:
                if (tableNumber % 3 == 0) {
                    dynamoDBTransactionWriteExpression = generateStringContainsTransactWriteExpression(stringAttribute.substring(2) + NON_MATCHING_STRING);
                    returnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure.ALL_OLD;
                } else if (tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringAttributeIfExistsTransactWriteExpression();
                }
                break;
            case MULTIPLE_INVALID_RETURN_VALUES_SET:
                if (tableNumber % 3 == 0 || tableNumber % 3 == 1) {
                    dynamoDBTransactionWriteExpression = generateStringContainsTransactWriteExpression(stringAttribute.substring(2) + NON_MATCHING_STRING);
                    returnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure.ALL_OLD;
                }
                break;
            case ONE_RESERVED_WORD:
                if (tableNumber % 3 == 0) {
                    dynamoDBTransactionWriteExpression = generateTransactWriteExpressionContainingReservedWord();
                }
                break;
            default:
                throw new IllegalArgumentException("Invalid expression mode: " + conditionExpressionMode + " passed in");
        }
        return new WriteExpressionAndReturnValue(dynamoDBTransactionWriteExpression, returnValuesOnConditionCheckFailure);
    }

    // Generates a write condition expression that'll check if either
    // matchingString1 or matchingString2 is exact match of *stringAttribute*'s value
    public static DynamoDBTransactionWriteExpression generateStringMatcherTransactWriteExpression(String matchingString1,
                                                                                                  String matchingString2) {
        DynamoDBTransactionWriteExpression writeExpression = new DynamoDBTransactionWriteExpression();
        Map<String, String> attributeNameMap = new HashMap<String, String>();
        attributeNameMap.put("#sA", "stringAttribute");
        writeExpression.withConditionExpression("(#sA IN (:attr1, :attr2))");
        Map<String, AttributeValue> attributeValueMap = new HashMap<String, AttributeValue>();
        attributeValueMap.put(":attr1", new AttributeValue(matchingString1));
        attributeValueMap.put(":attr2", new AttributeValue(matchingString2));
        writeExpression.withExpressionAttributeValues(attributeValueMap);
        writeExpression.withExpressionAttributeNames(attributeNameMap);
        return writeExpression;
    }

    // Generates a write condition expression that'll check if matchingSubString is *stringAttribute* value's substring
    public static DynamoDBTransactionWriteExpression generateStringContainsTransactWriteExpression(String matchingSubString) {
        DynamoDBTransactionWriteExpression writeExpression = new DynamoDBTransactionWriteExpression();
        Map<String, String> attributeNameMap = new HashMap<String, String>();
        attributeNameMap.put("#sA", "stringAttribute");
        writeExpression.withConditionExpression("contains(#sA, :attrV)");
        Map<String, AttributeValue> attributeValueMap = new HashMap<String, AttributeValue>();
        attributeValueMap.put(":attrV", new AttributeValue(matchingSubString));
        writeExpression.withExpressionAttributeValues(attributeValueMap);
        writeExpression.withExpressionAttributeNames(attributeNameMap);
        return writeExpression;
    }

    // Generates a write condition expression that'll check if matchingSubString is *stringAttribute* value's substring
    // Uses only ExpressionAttributeNames
    public static DynamoDBTransactionWriteExpression generateStringAttributeIfExistsWithExpressionAttributeNameTransactWriteExpression() {
        DynamoDBTransactionWriteExpression writeExpression = new DynamoDBTransactionWriteExpression();
        Map<String, String> attributeNameMap = new HashMap<String, String>();
        attributeNameMap.put("#sA", "stringAttribute");
        writeExpression.withConditionExpression("attribute_exists(#sA)");
        writeExpression.withExpressionAttributeNames(attributeNameMap);
        return writeExpression;
    }

    // Generates a write condition expression that'll check if subStringToMatch is *stringAttribute* value's substring
    // Uses only ExpressionAttributeValues
    public static DynamoDBTransactionWriteExpression generateStringContainsWithExpressionAttributeValuesTransactWriteExpression(String subStringToMatch) {
        DynamoDBTransactionWriteExpression writeExpression = new DynamoDBTransactionWriteExpression();
        writeExpression.withConditionExpression("contains(stringAttribute, :attrV)");
        Map<String, AttributeValue> attributeValueMap = new HashMap<String, AttributeValue>();
        attributeValueMap.put(":attrV", new AttributeValue(subStringToMatch));
        writeExpression.withExpressionAttributeValues(attributeValueMap);
        return writeExpression;
    }

    public static DynamoDBTransactionWriteExpression generateStringAttributeIfExistsTransactWriteExpression() {
        DynamoDBTransactionWriteExpression writeExpression = new DynamoDBTransactionWriteExpression();
        writeExpression.withConditionExpression("attribute_exists(stringAttribute)");
        return writeExpression;
    }

    public static DynamoDBTransactionWriteExpression generateTransactWriteExpressionContainingReservedWord() {
        DynamoDBTransactionWriteExpression writeExpression = new DynamoDBTransactionWriteExpression();
        writeExpression.withConditionExpression("attribute_exists(ABORT)");
        return writeExpression;
    }

    private static Object copyTransactWriteItemTestObject(Object obj) {
        if (obj.getClass().equals(StringAttributeClass.class)) {
            StringAttributeClass stringAttributeClassObject = (StringAttributeClass) obj;
            StringAttributeClass stringAttributeClassNewObject = new StringAttributeClass();
            stringAttributeClassNewObject.setRenamedAttribute(stringAttributeClassObject.getRenamedAttribute());
            stringAttributeClassNewObject.setStringAttribute(stringAttributeClassObject.getStringAttribute());
            stringAttributeClassNewObject.setKey(stringAttributeClassObject.getKey());
            return stringAttributeClassNewObject;
        } else if (obj.getClass().equals(TestItem.class)) {
            TestItem testItemObject = (TestItem) obj;
            TestItem testItemNewObject = new TestItem();
            testItemNewObject.setHashKey(testItemObject.getHashKey());
            testItemNewObject.setRangeKey(testItemObject.getRangeKey());
            testItemNewObject.setStringAttribute(testItemObject.getStringAttribute());
            testItemNewObject.setNonKeyAttribute(testItemObject.getNonKeyAttribute());
            testItemNewObject.setStringSetAttribute(testItemObject.getStringSetAttribute());
            return testItemNewObject;
        } else if (obj.getClass().equals(HashKeyRangeKeyClass.class)) {
            HashKeyRangeKeyClass hashKeyRangeKeyClassObject = (HashKeyRangeKeyClass) obj;
            HashKeyRangeKeyClass hashKeyRangeKeyClassNewObject = new HashKeyRangeKeyClass();
            hashKeyRangeKeyClassNewObject.setHashKey(hashKeyRangeKeyClassObject.getHashKey());
            hashKeyRangeKeyClassNewObject.setRangeKey(hashKeyRangeKeyClassObject.getRangeKey());
            hashKeyRangeKeyClassNewObject.setStringAttribute(hashKeyRangeKeyClassObject.getStringAttribute());
            return hashKeyRangeKeyClassNewObject;
        } else {
            throw new IllegalArgumentException("Unsupported class passed in: " + obj.getClass());
        }
    }

    // Replaces the operation at index in transactionWriteOperations with newObject
    public static void updateTransactionWriteOperationsWithNewObject(List<TransactionWriteOperation> transactionWriteOperations,
                                                                     Object newObject,
                                                                     int index) {
        TransactionWriteOperation oldOperation = transactionWriteOperations.get(index);
        updateTransactionWriteOperationsWithNewObjectAndExpression(transactionWriteOperations,
                                                                   newObject,
                                                                   oldOperation.getDynamoDBTransactionWriteExpression(),
                                                                   index);
    }


    // Replaces the operation at index in transactionWriteOperations with newObject and newDynamoDBTransactionWriteExpression
    public static void updateTransactionWriteOperationsWithNewObjectAndExpression(List<TransactionWriteOperation> transactionWriteOperations,
                                                                                  Object newObject,
                                                                                  DynamoDBTransactionWriteExpression newDynamoDBTransactionWriteExpression,
                                                                                  int index) {
        TransactionWriteOperation oldOperation = transactionWriteOperations.get(index);
        TransactionWriteOperation newTransactionWriteOperation = new TransactionWriteOperation(newObject,
                                                                                               oldOperation.getTransactionWriteOperationType(),
                                                                                               newDynamoDBTransactionWriteExpression,
                                                                                               oldOperation.getReturnValuesOnConditionCheckFailure());
        transactionWriteOperations.remove(index);
        transactionWriteOperations.add(index, newTransactionWriteOperation);
    }

    public static List<Object> extractAllObjectsFromTransactionWriteOperations(List<TransactionWriteOperation> transactionWriteOperations) {
        List<Object> objectList = new ArrayList<Object>();
        for (TransactionWriteOperation transactionWriteOperation : transactionWriteOperations) {
            objectList.add(transactionWriteOperation.getObject());
        }
        return objectList;
    }

    // Extracts objects that corresponding to put, update, delete.
    public static List<Object> extractObjectKeysForValidResponseSendingOperations(List<Object> allExistingObjects) {
        List<Object> responseObjectKeys = new ArrayList<Object>();
        for (int i = 0; i < 6; i++) {
            responseObjectKeys.add(allExistingObjects.get(i));
        }
        responseObjectKeys.add(allExistingObjects.get(8)); // For objectToBeDeleted1
        responseObjectKeys.add(allExistingObjects.get(9)); // For objectToBeDeleted2
        return responseObjectKeys;
    }

    public static List<Object> extractExpectedResponseObjects(List<Object> allExistingObjects) {
        List<Object> responseObjects = new ArrayList<Object>();
        for (int i = 0; i < 6; i++) {
            responseObjects.add(allExistingObjects.get(i));
        }
        responseObjects.add(null); // For objectToBeDeleted1
        responseObjects.add(null); // For objectToBeDeleted2
        return responseObjects;
    }
}
